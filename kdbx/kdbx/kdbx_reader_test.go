package kdbx_test

import (
	"reflect"
	"testing"

	kdbx "github.com/Skylli202/learn-go-with-tests/kdbx/kdbx"
)

// KDBX File Format Specification
// https://keepass.info/help/kb/kdbx.html

var KDBX_BINARY_SAMPLE []byte = []byte{
	// Signature 1 (uint32)
	0x03, 0xD9, 0xA2, 0x9A,
	// Signature 2 (uint32)
	0x67, 0xFB, 0x4B, 0xB5,
	// Version (uint32)
	0x01, 0x00, 0x04, 0x00,

	// Headers
	// ID:2, Length: 16, value: 31C1F2E6BF714350BE5805216AFC5AFF
	0x02,                   // 13
	0x10, 0x00, 0x00, 0x00, // 17
	0x31, 0xC1, 0xF2, 0xE6,
	0xBF, 0x71, 0x43, 0x50,
	0xBE, 0x58, 0x05, 0x21,
	0x6A, 0xFC, 0x5A, 0xFF, // 33

	// ID:3, Length: 4, value: 1 (GZip)
	0x03,                   // 34
	0x04, 0x00, 0x00, 0x00, // 38
	0x01, 0x00, 0x00, 0x00, // 42

	// ID: 4, Length: 32, value: 929CA119B0CC31D2ED682C97C226277A7F4A622B0EA9CFF8C537155F4F66CB86
	0x04,                   // 43
	0x20, 0x00, 0x00, 0x00, // 47
	0x92, 0x9C, 0xA1, 0x19,
	0xB0, 0xCC, 0x31, 0xD2,
	0xED, 0x68, 0x2C, 0x97,
	0xC2, 0x26, 0x27, 0x7A,
	0x7F, 0x4A, 0x62, 0x2B,
	0x0E, 0xA9, 0xCF, 0xF8,
	0xC5, 0x37, 0x15, 0x5F,
	0x4F, 0x66, 0xCB, 0x86, // 80

	// ID: 7, Length: 16, value: C136763088CB9E8625D5307AB17FFB1F
	0x07,                   // 81
	0x10, 0x00, 0x00, 0x00, // 85
	0xC1, 0x36, 0x76, 0x30,
	0x88, 0xCB, 0x9E, 0x86,
	0x25, 0xD5, 0x30, 0x7A,
	0xB1, 0x7F, 0xFB, 0x1F, // 101

	// // ID: 11, Length: 139, value:
	// 0x0B, // 102
	// 0x8B, 0x00, 0x00, 0x00,
	// 0x00, 0x01, 0x42, 0x05,
	// 0x00, 0x00, 0x00, 0x24,
	// 0x55, 0x55, 0x49, 0x44, 0x10, 0x00, 0x00,
}

func TestKDBX(t *testing.T) {
	t.Run("Extract Signature 1", func(t *testing.T) {
		db := kdbx.KDBX{
			Data: KDBX_BINARY_SAMPLE,
		}

		got := db.ReadSignture1()

		if got != 0x9AA2d903 {
			t.Errorf("got %02X, want 0x9AA2d903", got)
		}
	})

	t.Run("Extract Signature 2", func(t *testing.T) {
		db := kdbx.KDBX{
			Data: KDBX_BINARY_SAMPLE,
		}

		got := db.ReadSignture2()

		if got != 0xB54BFB67 {
			t.Errorf("got %02X, want 0xB54BFB67", got)
		}
	})

	t.Run("Extract format version", func(t *testing.T) {
		db := kdbx.KDBX{
			Data: KDBX_BINARY_SAMPLE,
		}

		major, minor := db.FormatVersion()

		var want_major uint32 = 0x0004
		var want_minor uint32 = 0x0001

		if major != want_major {
			t.Errorf("got %02X, want %02X", major, want_major)
		}

		if minor != want_minor {
			t.Errorf("got %02X, want %02X", minor, want_minor)
		}
	})

	t.Run("Read headers", func(t *testing.T) {
		db := kdbx.KDBX{
			Data: KDBX_BINARY_SAMPLE,
		}

		got := db.ReadHeaders()
		want := []kdbx.Header{
			{
				ID:     0x2,
				Length: 0x00000010,
				Value: []byte{
					0x31, 0xC1, 0xF2, 0xE6,
					0xBF, 0x71, 0x43, 0x50,
					0xBE, 0x58, 0x05, 0x21,
					0x6A, 0xFC, 0x5A, 0xFF,
				},
			},
			{
				ID:     0x03,
				Length: 0x04,
				Value: []byte{
					0x01, 0x00, 0x00, 0x00,
				},
			},
			{
				ID:     0x04,
				Length: 0x20,
				Value: []byte{
					0x92, 0x9C, 0xA1, 0x19,
					0xB0, 0xCC, 0x31, 0xD2,
					0xED, 0x68, 0x2C, 0x97,
					0xC2, 0x26, 0x27, 0x7A,
					0x7F, 0x4A, 0x62, 0x2B,
					0x0E, 0xA9, 0xCF, 0xF8,
					0xC5, 0x37, 0x15, 0x5F,
					0x4F, 0x66, 0xCB, 0x86,
				},
			},
			{
				ID:     0x07,
				Length: 0x10,
				Value: []byte{
					0xC1, 0x36, 0x76, 0x30,
					0x88, 0xCB, 0x9E, 0x86,
					0x25, 0xD5, 0x30, 0x7A,
					0xB1, 0x7F, 0xFB, 0x1F,
				},
			},
		}

		if !reflect.DeepEqual(got, want) {
			t.Errorf("len(got): %d, len(want): %d", len(got), len(want))
			for i, item := range got {
				t.Errorf("Got: ID:%d, Length:%d, Value: %X", item.ID, item.Length, item.Value)
				if i < len(want) {
					t.Errorf("Want: ID:%d, Length:%d, Value: %X", want[i].ID, want[i].Length, want[i].Value)
				}
				t.Errorf("\n")
			}
		}
	})
}
