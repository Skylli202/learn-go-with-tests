package kdbx_test

import (
	"bytes"
	"reflect"
	"testing"

	kdbx "github.com/Skylli202/learn-go-with-tests/kdbx/kdbx"
)

// KDBX File Format Specification
// https://keepass.info/help/kb/kdbx.html

var KDBX_BINARY_SAMPLE []byte = []byte{
	// Signature 1 (uint32)
	0x03, 0xD9, 0xA2, 0x9A,
	// Signature 2 (uint32)
	0x67, 0xFB, 0x4B, 0xB5,
	// Version (uint32)
	0x01, 0x00, 0x04, 0x00,

	// Headers
	// ID:2, Length: 16, value: 31C1F2E6BF714350BE5805216AFC5AFF
	0x02,                   // 13
	0x10, 0x00, 0x00, 0x00, // 17
	0x31, 0xC1, 0xF2, 0xE6,
	0xBF, 0x71, 0x43, 0x50,
	0xBE, 0x58, 0x05, 0x21,
	0x6A, 0xFC, 0x5A, 0xFF, // 33

	// ID:3, Length: 4, value: 1 (GZip)
	0x03,                   // 34
	0x04, 0x00, 0x00, 0x00, // 38
	0x01, 0x00, 0x00, 0x00, // 42

	// ID: 4, Length: 32, value: 929CA119B0CC31D2ED682C97C226277A7F4A622B0EA9CFF8C537155F4F66CB86
	0x04,                   // 43
	0x20, 0x00, 0x00, 0x00, // 47
	0x92, 0x9C, 0xA1, 0x19,
	0xB0, 0xCC, 0x31, 0xD2,
	0xED, 0x68, 0x2C, 0x97,
	0xC2, 0x26, 0x27, 0x7A,
	0x7F, 0x4A, 0x62, 0x2B,
	0x0E, 0xA9, 0xCF, 0xF8,
	0xC5, 0x37, 0x15, 0x5F,
	0x4F, 0x66, 0xCB, 0x86, // 80

	// ID: 7, Length: 16, value: C136763088CB9E8625D5307AB17FFB1F
	0x07,                   // 81
	0x10, 0x00, 0x00, 0x00, // 85
	0xC1, 0x36, 0x76, 0x30,
	0x88, 0xCB, 0x9E, 0x86,
	0x25, 0xD5, 0x30, 0x7A,
	0xB1, 0x7F, 0xFB, 0x1F, // 101

	// // ID: 11, Length: 139, value:
	// 0x0B, // 102
	// 0x8B, 0x00, 0x00, 0x00,
	// 0x00, 0x01, 0x42, 0x05,
	// 0x00, 0x00, 0x00, 0x24,
	// 0x55, 0x55, 0x49, 0x44, 0x10, 0x00, 0x00,
}

func TestKDBX(t *testing.T) {
	t.Run("Extract Signature 1", func(t *testing.T) {
		db := kdbx.KDBX{
			Data: KDBX_BINARY_SAMPLE,
		}

		got := db.ReadSignture1()

		if got != 0x9AA2d903 {
			t.Errorf("got %02X, want 0x9AA2d903", got)
		}
	})

	t.Run("Extract Signature 2", func(t *testing.T) {
		db := kdbx.KDBX{
			Data: KDBX_BINARY_SAMPLE,
		}

		got := db.ReadSignture2()

		if got != 0xB54BFB67 {
			t.Errorf("got %02X, want 0xB54BFB67", got)
		}
	})

	t.Run("Extract format version", func(t *testing.T) {
		db := kdbx.KDBX{
			Data: KDBX_BINARY_SAMPLE,
		}

		major, minor := db.FormatVersion()

		var want_major uint32 = 0x0004
		var want_minor uint32 = 0x0001

		if major != want_major {
			t.Errorf("got %02X, want %02X", major, want_major)
		}

		if minor != want_minor {
			t.Errorf("got %02X, want %02X", minor, want_minor)
		}
	})

	t.Run("Read headers", func(t *testing.T) {
		db := kdbx.KDBX{
			Data: KDBX_BINARY_SAMPLE,
		}

		got := db.ReadHeaders()
		want := []kdbx.Header{
			{
				ID:     0x2,
				Length: 0x00000010,
				Value: []byte{
					0x31, 0xC1, 0xF2, 0xE6,
					0xBF, 0x71, 0x43, 0x50,
					0xBE, 0x58, 0x05, 0x21,
					0x6A, 0xFC, 0x5A, 0xFF,
				},
			},
			{
				ID:     0x03,
				Length: 0x04,
				Value: []byte{
					0x01, 0x00, 0x00, 0x00,
				},
			},
			{
				ID:     0x04,
				Length: 0x20,
				Value: []byte{
					0x92, 0x9C, 0xA1, 0x19,
					0xB0, 0xCC, 0x31, 0xD2,
					0xED, 0x68, 0x2C, 0x97,
					0xC2, 0x26, 0x27, 0x7A,
					0x7F, 0x4A, 0x62, 0x2B,
					0x0E, 0xA9, 0xCF, 0xF8,
					0xC5, 0x37, 0x15, 0x5F,
					0x4F, 0x66, 0xCB, 0x86,
				},
			},
			{
				ID:     0x07,
				Length: 0x10,
				Value: []byte{
					0xC1, 0x36, 0x76, 0x30,
					0x88, 0xCB, 0x9E, 0x86,
					0x25, 0xD5, 0x30, 0x7A,
					0xB1, 0x7F, 0xFB, 0x1F,
				},
			},
		}

		if !reflect.DeepEqual(got, want) {
			t.Errorf("len(got): %d, len(want): %d", len(got), len(want))
			for i, item := range got {
				t.Errorf("Got: ID:%d, Length:%d, Value: %X", item.ID, item.Length, item.Value)
				if i < len(want) {
					t.Errorf("Want: ID:%d, Length:%d, Value: %X", want[i].ID, want[i].Length, want[i].Value)
				}
				t.Errorf("\n")
			}
		}
	})
}

func TestVariantDictionaryParsing(t *testing.T) {
	t.Run("Properly parse a string variant dictionary", func(t *testing.T) {
		value := []byte{
			// Version
			0x00, 0x01,
			// Type: byte
			0x42,
			// Name size: 5
			0x05, 0x00, 0x00, 0x00,
			// Name: $UUID
			0x24, 0x55, 0x55, 0x49, 0x44,
			// Value Size: 16
			0x10, 0x00, 0x00, 0x00,

			// Value:
			0xEF, 0x63, 0x6D, 0xDF,
			0x8C, 0x29, 0x44, 0x4B,
			0x91, 0xF7, 0xA9, 0xA4,
			0x03, 0xE3, 0x0A, 0x0C,
		}
		// 0x05, 0x01, 0x00, 0x00, 0x00, 0x49, 0x08, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x4D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x50, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x42, 0x01, 0x00, 0x00, 0x00, 0x53, 0x20, 0x00, 0x00, 0x00, 0x36, 0x42, 0xE0, 0x29, 0xCF, 0xBD, 0x3B, 0x2F, 0x14, 0x8E, 0xDA, 0xCB, 0x6C, 0xCE, 0xF3, 0x30, 0x5B, 0xE6, 0xE9, 0x85, 0xF6, 0x6D, 0x17, 0xAB, 0x07, 0xB7, 0x5B, 0xEE, 0x65, 0xE1, 0x7E, 0x0D, 0x04, 0x01, 0x00, 0x00, 0x00, 0x56, 0x04, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00,

		got := kdbx.DecodeVariantDictionaryItem(value)
		want := kdbx.VariantDictionaryItem{
			Version:   0x1,
			ValueType: kdbx.VARIANT_DICTIONARY_TYPE_BYTE_ARRAY,
			NameSize:  0x05,
			Name:      "$UUID",
			ValueSize: 16,
			Value: []byte{
				0xEF, 0x63, 0x6D, 0xDF,
				0x8C, 0x29, 0x44, 0x4B,
				0x91, 0xF7, 0xA9, 0xA4,
				0x03, 0xE3, 0x0A, 0x0C,
			},
		}

		if got.Version != want.Version {
			t.Errorf("[Version] got %d, want %d", got.Version, want.Version)
		}

		if got.ValueType != want.ValueType {
			t.Errorf("[ValueType] got: 0x%2X, want 0x%2X", got.ValueType, want.ValueType)
		}

		if got.NameSize != want.NameSize {
			t.Errorf("[NameSize] got: 0x%2X, want 0x%2X", got.NameSize, want.NameSize)
		}

		if got.Name != want.Name {
			t.Errorf("[Name] got: 0x%2X, want 0x%2X", got.Name, want.Name)
		}

		if got.ValueSize != want.ValueSize {
			t.Errorf("[ValueSize] got: 0x%2X, want 0x%2X", got.ValueSize, want.ValueSize)
		}

		if !bytes.Equal(got.Value, want.Value) {
			t.Errorf("[Value] got: 0x%2X, want 0x%2X", got.Value, want.Value)
		}
	})
}

func logVariantDictionary(t *testing.T, v kdbx.VariantDictionaryItem) {
	t.Errorf(`Version: %d, ValueType: %s (0x%2X), 
  NameSize: %d, Name: %s
  ValueSize: %d, Value: 
`,
		v.Version, kdbx.VARIANT_DICTIONARY_TYPE_NAME[v.ValueType], v.ValueType,
		v.NameSize,
		v.Name,
		v.ValueSize,
	)
}
